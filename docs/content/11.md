## 机器学习-实验评估方法与性能度量

> 本博文为《机器学习-周志华》的学习笔记。

![在这里插入图片描述](https://img-blog.csdnimg.cn/228dc11de42544f89533580b951d47fb.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAQ2FuZHlfXzE=,size_20,color_FFFFFF,t_70,g_se,x_16)

在现实任务中，我们往往有多种学习算法可供选择，甚至对同一个学习算法，当使用不同参数配置时，也会产生不同的模型。我们该选择哪一个学习算法、使用哪一种参数配置呢？这就是机器学习中的**模型选择**问题。模型选择当然是选择出**泛化误差**(模型适应新样本的能力)小的那个模型，那问题又来了，怎么去衡量模型的泛化误差呢？这里我们需要用到一系列的**实验评估方法**获得某种性能度量指标，然后依据指标对学习器性能比较之后得到理想的模型。

 ### **评估方法**
 通常，我们可以通过实验测试来对学习器的泛化误差进行评估。于是，我们需要一个**测试集**或称**验证集**来对模型进行评估。然后在测试集上得到测试误差作为泛化误差的近似。但需注意，测试集应尽可能与训练集互斥，理由是：**考试题目为平时的练习题将失去考试的意义**。
 构造测试集的方法主要有以下几种：
 #### 1.留出法
 留出法直接将数据集划分为两个互斥的集合，一个作为训练集$S$，一个作为测试集$T$，即$D=S\cup T,S\cap T=\oslash$.其划分方式及其比例如下图所示：
 ![在这里插入图片描述](https://img-blog.csdnimg.cn/50356263cdc14ef0946df7923bb2bf90.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAQ2FuZHlfXzE=,size_20,color_FFFFFF,t_70,g_se,x_16)
 但需注意，这种划分并不是任意满足比例就行，应遵循一个**分层采样**原则，即训练集和测试集所包含的正反样例的比例要尽可能接近。例如：通过对$D$分层采样而获得含70%样本的训练集$S$和含30%样本的测试集$T$，若$D$包含500个正例、500个反例，则分层采样得到$S$应包含350个正例、350个反例，而$T$则包含150个正例和150个反例。一般而言，测试集应至少包含30个样例。
 #### 2.交叉验证法
 交叉验证法先将数据集$D$划分为$k$个大小相似的互斥子集，即$D=D_1\cup  D_2\cup \cdots \cup D_k,D_i\cap D_j=\oslash (i\neq j)$,同样每个子集均来自**分层采样**。每次选择$k-1$个子集作为训练集，余下的那个子集作为测试集。这样重复以上步骤$k$次，能够将每个子集都测试一遍，一般，$k$值常设置为10，称为**10折交叉验证**。
 ![在这里插入图片描述](https://img-blog.csdnimg.cn/44ace4ac1e6e43adaa8959ff403305cd.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAQ2FuZHlfXzE=,size_20,color_FFFFFF,t_70,g_se,x_16)
 在测试的过程中出现的问题是：由于样本波动性太大，每一次的交叉验证之后往往测试结果也具有一定的方差，解决办法便是**留一法**(Leave-One-Out)，即每个样本作为一个集合，对每一次交叉验证对n-1个样本进行训练，对最后一个样本进行测试。显然这种做法可以一定程度上抑制训练样本规模的波动，但计算复杂度提高了不少。
  #### 3.自助法
  这种方法借鉴了概率论中的伯努利试验，即采用放回抽样的方法从包含m个样本的数据集$D$中独立重复进行m次抽取动作得到的样本作为训练集$D'$，$D\setminus D'$作为测试集。某个样本在m次采样后始终不被采到的概率为：
  $$P=\left ( 1-\frac{1}{m} \right )^m$$
  $$\lim_{}\left ( 1-\frac{1}{m} \right )^m=\frac{1}{e}\approx 0.368$$
  即通过自助采样，初始数据集$D$中约有36.8%的样本未出现在采样数据集$D'$中
  ![在这里插入图片描述](https://img-blog.csdnimg.cn/02ee309673714d1288668b9ddb81cb32.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAQ2FuZHlfXzE=,size_20,color_FFFFFF,t_70,g_se,x_16)
  以上三种方法便是常见的实验评估方法，采用上述方法划分训练集、测试集之后，可用训练集训练模型，用测试集测试出相应的性能度量指标。性能度量反应了任务需求，使用不同的性能度量往往会产生不同的评判结果。接下来介绍几种常见的性能度量指标：
   ### **性能度量**
   #### 1.错误率与精度
   用测试集测试模型之后，可得到一系列测试结果，假设1为正例，0为反例：
   ![在这里插入图片描述](https://img-blog.csdnimg.cn/12148f844c2d405f8c5df4a85914fc69.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAQ2FuZHlfXzE=,size_15,color_FFFFFF,t_70,g_se,x_16)
错误率是分类错误的样本数占样本总数的比例，精度是分类正确的样本数占样本总数的比例，错误率计算公式：
   
   $$E(f;D)=\frac{1}{m}\sum_{i=1}^{m}\mathbb{I}(f(x_i\neq y_i))$$
   精度计算公式：
  $$ ACC=1-E(f;D)$$
   #### 2.P-R曲线及F1度量
   在实际中，错误率与精度并不能满足我们了解整个模型性能的全部需求，例如我们想知道有多少样本是反例而被误判成了正例或者有多少样本是正例而被误判成了反例，显然错误率和精度不能体现上述指标。
   对于二分类问题，我们常常用混淆矩阵来度量我们所需要的结果：
   ![在这里插入图片描述](https://img-blog.csdnimg.cn/210c180afcb641f3ad286753cd2f3736.png)
   很显然，对角线元素是我们所期待的结果。
![在这里插入图片描述](https://img-blog.csdnimg.cn/66766dced4ed40f18ad803defcf35459.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAQ2FuZHlfXzE=,size_20,color_FFFFFF,t_70,g_se,x_16)     
   查准率P与查全率R可以这样定义：
   $$P=\frac{TP}{TP+FP}$$
   $$P=\frac{TP}{TP+FN}$$
   对于P和R我们可以这样理解，查准率P就是在所测试的样本中的准确程度，准确度越高越好，即分母应该是预测为正例的样本和；相反，查全率希望真实样本中的正例被尽可能多的调出来，越全越好，即分母应该是真实值为正例的样本和。
   查准率和查全率往往是一对矛盾量，若想提高查全率则势必会降低查准率，我们期待的是查准率和查全率均得到较高的值，一种度量手段便是绘制**P-R曲线**。
   P-R曲线的生成方法：根据学习器的预测结果对样本进行排序，排在前面的是学习器认为最可能是正例的样本，排在最后的是最不可能是正例的样本，按此顺序逐个将样本作为正例预测，则每次可以计算出当前的查全率、查准率，以查全率为横轴、查准率为纵轴做图，得到的查准率-查全率曲线即为P-R曲线。
   ![在这里插入图片描述](https://img-blog.csdnimg.cn/7a3ee2b82adc43b589f3e143db5abec5.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAQ2FuZHlfXzE=,size_20,color_FFFFFF,t_70,g_se,x_16)

   P-R曲线直观地显示了学习器在样本总体上的查全率、查准率。在比较时，若一个学习器的P-R曲线被另一个学习器完全包住，则可断言后者的性能由于前者。
   如上图中能够看出学习器B性能优于A，学习器性能C优于A，学习器性能D优于A,但学习器B、C、D该如何比较？
   我们采用**平衡点**(Break-Event Point)进行度量，它是**查准率=查全率**时的取值，![在这里插入图片描述](https://img-blog.csdnimg.cn/7d111396c5454374b2d89716fd5b8cca.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAQ2FuZHlfXzE=,size_20,color_FFFFFF,t_70,g_se,x_16)
   同样，平衡点距离原点越远，性能越好，通过比较平衡点可得出学习器B=C性能由于D，但学习器B和C的性能就真是就相等了么？，显然是不一样的。
   可见光从P-R曲线也不太能反应出学习器的全部信息，我们可利用F1度量方式对B和C的性能进行度量。
   F1度量时基于查准率和查全率的调和平均定义的：
   $$\frac{1}{F1}=\frac{1}{2}(\frac{1}{P}+\frac{1}{R})=\frac{2\times P\times R}{P+R}$$
   #### 3.ROC与AUC
   ROC全称“受试者工作特征”(Receiver Operating Characteristic)曲线。类比于P-R曲线，我们这里更换了P-R曲线的横纵坐标，其中纵坐标为TPR(真正例率)，横坐标为FPR(假正例率）：
   $$TPR=\frac{TP}{TP+FN}$$
   $$FPR=\frac{FP}{TN+FP}$$
   细心朋友会发现，真正例率TPR其实就是前面所说的查全率R，这里只是换了一个名字。
   有混淆举证可知，我们希望真正例率TPR尽可能大，而假正例率FPR尽可能小，于是在ROC图中我们希望曲线能位于左上部分。
   ![在这里插入图片描述](https://img-blog.csdnimg.cn/d99161c74ecc42d9a24b0be25a22bd17.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAQ2FuZHlfXzE=,size_20,color_FFFFFF,t_70,g_se,x_16)
   现实任务是根据有限个测试样本来绘制ROC图，此时仅能获得有限个坐标对，无法产生上图所示的光滑曲线。绘图过程可以如下：对学习器的预测结果进行排序，排在最前面的样本被认为最可能是正例的样本。按此顺序把样本作为正例进行预测，则每次可以计算当前的TPR和FPR。
   假设我们已经训练得到了一个学习器$f(s)$,用该学习器对8个测试样本进行预测(4个正例，4个反例）预测结果：
   ![在这里插入图片描述](https://img-blog.csdnimg.cn/22f1faed00234eb78005c0df0815ec6c.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAQ2FuZHlfXzE=,size_20,color_FFFFFF,t_70,g_se,x_16)
   首先将阈值设置为1，易得TPR=FPR=0；接着将分类阈值从大到小依次设为每个样本的预测值，也就是依次设为0.77，0.62，0.58，0.47，0.33，0.23，0.15。当阈值为0.77时，首先计算混淆举证：![在这里插入图片描述](https://img-blog.csdnimg.cn/cbe1d7565f6742d48ea2335e60493840.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAQ2FuZHlfXzE=,size_20,color_FFFFFF,t_70,g_se,x_16)
   得到横纵坐标：$$TPR_{0.77}=\frac{TP}{TP+FN}=\frac{1}{4}=0.25$$
   $$FPR_{0.77}=\frac{FP}{TN+FP}=\frac{0}{4}=0$$,接下来步骤相同，得到8个点的横纵坐标如下：
   ![在这里插入图片描述](https://img-blog.csdnimg.cn/910bf361c017481aa6d942f013caafaa.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAQ2FuZHlfXzE=,size_20,color_FFFFFF,t_70,g_se,x_16)
   绘制出ROC曲线：
   ![在这里插入图片描述](https://img-blog.csdnimg.cn/6d2b0f9953934b92a8a05354335379a6.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAQ2FuZHlfXzE=,size_20,color_FFFFFF,t_70,g_se,x_16)

   进行学习器比较时，与P-R曲线相似，若一个学习器的ROC曲线被另一个学习器曲线完全抱住，则可断言后者性能优于前者；若两个学习器的ROC曲线发生交叉，则难以一般性地断言孰优孰劣。此时较为合理的判据是ROC面积，即**AUC**。
   $$AUC=\frac{1}{2}\sum_{i=1}^{m}(x_{i+1}-x_i)(y_i+y_{i+1})$$
   对这个公式我们可以这样理解，对ROC曲线截取一个小梯形，有梯形公式：
   $$\Delta S=\frac{1}{2}(上底+下底)\times 高$$
   ![在这里插入图片描述](https://img-blog.csdnimg.cn/1c5e4a2341434035a05dd2d15f07add9.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAQ2FuZHlfXzE=,size_20,color_FFFFFF,t_70,g_se,x_16)
对所有小的梯形面积求和便能得到上述AUC的计算公式。
![在这里插入图片描述](https://img-blog.csdnimg.cn/229cf510db1c44ee8d4e63f79de46f69.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAQ2FuZHlfXzE=,size_20,color_FFFFFF,t_70,g_se,x_16)
定义“损失”：
$$\iota _{rank}=\frac{1}{m^+m^-}\sum_{x^+\in D^+}^{}\sum_{x^-\in D^-}^{}(\mathbb{I}(f(x^+)<f(x^-))+\frac{1}{2}\mathbb{I}(f(x^+)=f(x^-)))$$
直观上看，该式子核心就是数格子数。在下述ROC曲线图中，若正例的预测值小于反例，则记一个“罚分”，对应于一个红色小方格；若相等，则记0.5个“罚分”，对应于半个小方格。将所有小方格和半个小方格各数加起来乘上每个小方格的面积$\frac{1}{m^+m^-}$就是最终的$\iota _{rank}$.
显然，
$$AUC=1-\iota _{rank}$$
![在这里插入图片描述](https://img-blog.csdnimg.cn/a9b9214e8d7345a48e4a131e83968b2b.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAQ2FuZHlfXzE=,size_20,color_FFFFFF,t_70,g_se,x_16)
 #### 4.代价曲线
 在现实任务中，我们常常会遇到这种情况：例如在医疗诊断中错误吧患者诊断为健康人与错误地把健康人诊断为患者，看起来都是犯了“一次错误”，但后者的影响是增加了进一步诊断的麻烦，前者的结果却可能是丧失了拯救生命的最佳时机。为权衡不同类型错误所造成的不同损失，可为不同的错误定义相应的权重，称为“非均等代价”。
 例如，我们可定义如下代价矩阵：
 ![在这里插入图片描述](https://img-blog.csdnimg.cn/24cc2c5fe1ea455ab8907bb385c5a257.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAQ2FuZHlfXzE=,size_20,color_FFFFFF,t_70,g_se,x_16)
 于是，可修改前面的精度公式：
    $$E(f;D;cost)=\frac{1}{m}(\sum_{x_i\in D^+}^{m}\mathbb{I}(f(x_i\neq y_i))\times cost_{01}+\sum_{x_i\in D^-}^{m}\mathbb{I}(f(x_i\neq y_i))\times cost_{10})$$
  在非均等代价下，我们的绘制代价曲线图：
  横轴：
  ![在这里插入图片描述](https://img-blog.csdnimg.cn/e8f4cdaa56ed4488bdb844bfa66f4b97.png)
  纵轴：
  ![在这里插入图片描述](https://img-blog.csdnimg.cn/f5e3313642b2444dab64de1694bf9a89.png)
  将1带入2，得到(看作$P(+)$为自变量）：
  $$cost_{norm}=P(+)(FNR-FPR)-FPR$$
  即一个ROC曲线上的点(FNR=1-TPR,FPR)对应一条直线，然后取所有线段的下届，围成的面积即为在所有条件下学习器的期望总体代价。
  ![在这里插入图片描述](https://img-blog.csdnimg.cn/28a17941eaba43b0bdf933e5821d7a5a.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAQ2FuZHlfXzE=,size_20,color_FFFFFF,t_70,g_se,x_16)






 
 
 




   
   


   
   

   

   
   

   


   
   
   
  

  
 
 
 


 
 

 
 
 
 

 
